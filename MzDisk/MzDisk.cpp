#include <stdlib.h>
#include <stdexcept>
#include <iterator>
#include "Format.hpp"
#include "FileData.hpp"
#include "MzDisk.hpp"

// 漢字の1バイト目か
#define IsKanji(c) ( (unsigned char)((int)((unsigned char)(c) ^ 0x20) - 0x0A1) < 0x3C )

/* MZ-80B,2000,2200 */
const char MzDisk::asciiCodeAnk[] =
{
	" !\x22#$%&\x27()*+,-./"	/* 20 */
	"0123456789:;<=>?"			/* 30 */
	"@ABCDEFGHIJKLMNO"			/* 40 */
	"PQRSTUVWXYZ[\\]^*"			/* 50 */
	"*abcdefghijklmno"			/* 60 */
	"pqrstuvwxyz{|}~."			/* 70 */
	"................"			/* 80 */
	".\\.............."			/* 90 */
	".｡｢｣WXｦｧｨｩｪｫﾔﾕﾖｯ"			/* A0 */
	"*ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ"			/* B0 */
	"ﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ"			/* C0 */
	"ﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝﾞﾟ"			/* D0 */
	"ZABCDEFGHIJKLMNO"			/* E0 */
	"0123456789PQRST."			/* F0 */
};
const char MzDisk::asciiCodeSjis[] =
{
	"　！”＃＄％＆’（）＊＋，−．／"	/* 20 */
	"０１２３４５６７８９：；＜＝＞？"	/* 30 */
	"＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯ"	/* 40 */
	"ＰＱＲＳＴＵＶＷＸＹＺ［＼］＾￣"	/* 50 */
	"´ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏ"	/* 60 */
	"ｐｑｒｓｔｕｖｗｘｙｚ｛｜｝〜※"	/* 70 */
	"※↓↑→←※※※※※※※※※※※"	/* 80 */
	"※￥※●○※※※※※※※※※※※"	/* 90 */
	"※。「」ＷＸヲァィゥェォャュョッ"	/* A0 */
	"※アイウエオカキクケコサシスセソ"	/* B0 */
	"タチツテトナニヌネノハヒフヘホマ"	/* C0 */
	"ミムメモヤユヨラリルレロワン゛゜"	/* D0 */
	"ＺＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯ"	/* E0 */
	"０１２３４５６７８９ＰＱＲＳＴπ"	/* F0 */
};

/* MZ-80A */
const char MzDisk::asciiCodeAnk80A[] =
{
	" !\x22#$%&\x27()*+,-./"	/* 20 */
	"0123456789:;<=>?"			/* 30 */
	"@ABCDEFGHIJKLMNO"			/* 40 */
	"PQRSTUVWXYZ[.].."			/* 50 */
	"................"			/* 60 */
	"................"			/* 70 */
	"}..............."			/* 80 */
	"_.e`~.tgh.bxdrpc"			/* 90 */
	"qazwsui..kfv...j"			/* A0 */
	"n..m...ol....y{."			/* B0 */
	"................"			/* C0 */
	"................"			/* D0 */
	"................"			/* E0 */
	"................"			/* F0 */
};
const char MzDisk::asciiCodeSjis80A[] =
{
	"　！”＃＄％＆’（）＊＋，−．／"	/* 20 */
	"０１２３４５６７８９：；＜＝＞？"	/* 30 */
	"＠ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯ"	/* 40 */
	"ＰＱＲＳＴＵＶＷＸＹＺ［＼］↑←"	/* 50 */
	"※※※※※※※※※※※※※※※※"	/* 60 */
	"※※※※※※※※※※※※※※※※"	/* 70 */
	"※┼※※※※※※※※※※※※※※"	/* 80 */
	"※※※※※※※※※※※※※※β※"	/* 90 */
	"※※※※※※※※※※※※※※｛※"	/* A0 */
	"※※※※※※※※※※※※※※※※"	/* B0 */
	"※※※※※※→※※※※├※└┐※"	/* C0 */
	"┌┴┬┤※※※※※※※※※┘※※"	/* D0 */
	"※※※※※※※※※※※※※＼／※"	/* E0 */
	"※●※※※※×○※※◆£↓│※π"	/* F0 */
};

//============================================================================
// コンストラクタ
//============================================================================
MzDisk::MzDisk()
:mediaType(0)
,diskType(0)
,bitmap(NULL)
,fileType(0)
,clusterSize(0)
,dirSector(16)
{
	this->sectorSize = 256;
}

//============================================================================
// デストラクタ
//============================================================================
MzDisk::~MzDisk()
{
}

int MzDisk::DiskType(void)
{
	return Disk::MZ2000;
}

std::string MzDisk::DiskTypeText(void)
{
	if(this->diskType == DISKTYPE_MZ2500_2DD)
	{
		return "2D(80) MZ-2500ディスク";
	}
	else if(this->diskType == DISKTYPE_MZ2500_2DD40)
	{
		return "2D(40) MZ-2500ディスク";
	}
	else if(this->diskType == DISKTYPE_MZ2500_2DD35)
	{
		return "2D(35) MZ-2500ディスク";
	}
	else if(this->diskType == DISKTYPE_MZ80B_2D35)
	{
		return "2D(35) MZ-80B/700/1500/2000/2200ディスク";
	}
	else if(this->diskType == DISKTYPE_MZ2000_2D40)
	{
		return "2D(40) MZ-2000/2200ディスク";
	}
	else if(this->diskType == DISKTYPE_MZ80A_2D35)
	{
		return "2D(35) MZ-80Aディスク";
	}
	return "ディスクタイプ不明";
}

//============================================================================
//  ディスクイメージをフォーマットする
//----------------------------------------------------------------------------
// In  : path = イメージファイル
//     : type
//     : DISKTYPE_MZ2500_2DD   // MZ-2500
//     : DISKTYPE_MZ2500_2DD40 // MZ-2500
//     : DISKTYPE_MZ2500_2DD35 // MZ-2500
//     : DISKTYPE_MZ80B_2D35   // MZ-80B (MZ-80BF)
//     : DISKTYPE_MZ2000_2D40  // MZ-2000 (MZ-1F07)
// Out : エラーコード ( 0 = 正常 )
//============================================================================
void MzDisk::Format(int type, int volumeNumber)
{
	if(type == DISKTYPE_MZ2500_2DD)
	{
		this->mediaType = D88Image::DISK_2DD_80_256_16;
	}
	else if(type == DISKTYPE_MZ2500_2DD40)
	{
		this->mediaType = D88Image::DISK_2DD_40_256_16;
	}
	else if(type == DISKTYPE_MZ2500_2DD35)
	{
		this->mediaType = D88Image::DISK_2DD_35_256_16;
	}
	else if(type == DISKTYPE_MZ80B_2D35)
	{
		this->mediaType = D88Image::DISK_2D_35_256_16;
	}
	else if(type == DISKTYPE_MZ2000_2D40)
	{
		this->mediaType = D88Image::DISK_2D_40_256_16;
	}
	else if(type == DISKTYPE_MZ80A_2D35)
	{
		this->mediaType = D88Image::DISK_2D_35_256_16;
	}
	else
	{
		return;
	}
	this->diskType = type;
	// 物理フォーマット
	this->image.Format(this->mediaType, 0);//0xBF ^ 0xFF);
	// 論理フォーマット
	if(type == DISKTYPE_MZ80B_2D35 || type == DISKTYPE_MZ2000_2D40 || type == DISKTYPE_MZ80A_2D35)
	{
		// ディレクトリ
		std::vector<unsigned char> buffer;
		buffer.resize(static_cast<size_t>(this->sectorSize) * 8, 0);
		buffer[0] = 0x80;
		buffer[1] = static_cast<unsigned char>(volumeNumber);
		WriteSector(buffer, 16, 8);
	}
	else
	{
		// IPL
		std::vector<unsigned char> buffer;
		buffer.resize(this->sectorSize, 0);
		IPL* ipl = reinterpret_cast<IPL*>(&buffer[0]);
		ipl->machine = 0x04; // MZ-2500データディスク
		WriteSector(buffer, 0, 1);
		// ディレクトリ
		buffer.clear();
		buffer.resize(static_cast<size_t>(this->sectorSize) * 8, 0);
		for(int i = 0; i < 64; ++ i)
		{
			memset(&buffer[static_cast<size_t>(i) * 32], 0xD, 17);
			buffer[static_cast<size_t>(i) * 32] = 0x00;
		}
		buffer[0] = 0x80;
		WriteSector(buffer, 16, 8);
	}
	// ビットマップ
	this->bitmap.clear();
	this->bitmap.resize(this->sectorSize, 0);
	if(type == DISKTYPE_MZ2500_2DD)
	{
		this->bitmap[0] = 0x01;
		this->bitmap[1] = 0x18;
		this->bitmap[2] = 0x18;
		this->bitmap[3] = 0x00;
		this->bitmap[4] = 0x00;
		this->bitmap[5] = 0x05;
		this->bitmap[255] = 0x01;
	}
	else if(type == DISKTYPE_MZ2500_2DD40)
	{
		this->bitmap[0] = 0x01;
		this->bitmap[1] = 0x30;
		this->bitmap[2] = 0x30;
		this->bitmap[3] = 0x00;
		this->bitmap[4] = 0x00;
		this->bitmap[5] = 0x05;
		this->bitmap[255] = 0x00;
	}
	else if(type == DISKTYPE_MZ2500_2DD35)
	{
		this->bitmap[0] = 0x01;
		this->bitmap[1] = 0x30;
		this->bitmap[2] = 0x30;
		this->bitmap[3] = 0x00;
		this->bitmap[4] = 0x60;
		this->bitmap[5] = 0x04;
		this->bitmap[255] = 0x00;
	}
	else if((type == DISKTYPE_MZ80B_2D35) || (type == DISKTYPE_MZ80A_2D35))
	{
		this->bitmap[0] = static_cast<unsigned char>(volumeNumber);
		this->bitmap[1] = 0x30;
		this->bitmap[2] = 0x30;
		this->bitmap[3] = 0x00;
		this->bitmap[4] = 0x60;
		this->bitmap[5] = 0x04;
		this->bitmap[255] = 0x00;
	}
	else if(type == DISKTYPE_MZ2000_2D40)
	{
		this->bitmap[0] = static_cast<unsigned char>(volumeNumber);
		this->bitmap[1] = 0x30;
		this->bitmap[2] = 0x30;
		this->bitmap[3] = 0x00;
		this->bitmap[4] = 0x00;
		this->bitmap[5] = 0x05;
		this->bitmap[255] = 0x00;
	}
	WriteSector(this->bitmap, 15, 1);
	// ディスク情報格納
	this->clusterSize = this->sectorSize * (this->bitmap[255] + 1);
	ReadDirectory();
}

int MzDisk::Load(std::string path)
{
	dms::FileData fileData;
	fileData.Load(path.c_str());
	std::vector<unsigned char> buffer;
	fileData.GetBuffer(buffer);
	return Load(buffer);
}

//============================================================================
//  ディスクイメージを読み込んでメモリに展開する
//----------------------------------------------------------------------------
// In  : image = イメージファイルメモリイメージ
// Out : エラーコード ( 0 = 正常 )
//============================================================================
int MzDisk::Load(const std::vector<unsigned char>& buffer)
{
	try
	{
		const void* image = &buffer[0];
		const D88Image::Header* header = reinterpret_cast<const D88Image::Header*>(image);
		this->image.Load(image, header->diskSize);
		Update();
		return 0;
	}
	catch(const std::exception& error)
	{
		(void)error;
		return 1;
	}
}

void MzDisk::Update(void)
{
	D88Image::Header header;
	this->image.GetHeader(header);
	this->bitmap.clear();
	ReadSector(this->bitmap, 15, 1);
	// ディスク情報格納
	int trackMax = 0;
	for(int i = 0; i < D88Image::TRACK_COUNT; ++ i)
	{
		if(header.trackTable[i] != 0)
		{
			++ trackMax;
		}
	}
	this->clusterSize = this->sectorSize * (this->bitmap[255] + 1);
	ReadDirectory();
	// タイプ判定
	this->mediaType = header.diskType;
	std::vector<unsigned char> buffer;
	buffer.clear();
	ReadSector(buffer, 0, 1);
	IPL* ipl = reinterpret_cast<IPL*>(&buffer[0]);
	if(this->mediaType == 0x00)
	{
		// 2D
		if(trackMax == 70)
		{
			if(ipl->machine == 2)
			{
				this->diskType = DISKTYPE_MZ80A_2D35;
			}
			else
			{
				this->diskType = DISKTYPE_MZ80B_2D35;
			}
		}
		else
		{
			this->diskType = DISKTYPE_MZ2000_2D40;
		}
	}
	else
	{
		// 2DD
		if(trackMax == 70)
		{
			this->diskType = DISKTYPE_MZ2500_2DD35;
		}
		else if(trackMax == 80)
		{
			this->diskType = DISKTYPE_MZ2500_2DD40;
		}
		else
		{
			this->diskType = DISKTYPE_MZ2500_2DD;
		}
	}
}

int MzDisk::Save(std::string path)
{
	std::vector<unsigned char> buffer;
	int result = Save(buffer);
	if(result != 0)
	{
		return result;
	}
	dms::FileData fileData;
	fileData.SetBuffer(&buffer[0], buffer.size());
	fileData.Save(path.c_str());
	return 0;
}

//============================================================================
//  ディスクイメージを作成する
//----------------------------------------------------------------------------
// In  : buffer = イメージファイルを格納するバッファ
// Out : エラーコード ( 0 = 正常 )
//============================================================================
int MzDisk::Save(std::vector<unsigned char>& buffer)
{
	try
	{
		FlushWrite();
		this->image.Save(buffer);
		return 0;
	}
	catch(const std::exception& error)
	{
		(void)error;
		return 1;
	}
}

//============================================================================
//  ディスクイメージからファイルを取り出す
//----------------------------------------------------------------------------
// In  : dirindex = 取り出すファイルのディレクトリ番号
//     : path = 保存位置
//     : mode = ファイルモード
// Out : 0 = 成功
//============================================================================
int MzDisk::GetFile(int dirindex, std::string path, unsigned int mode)
{
	try
	{
		FILE *fp;
		if(fopen_s(&fp, path.c_str(), "wb") != 0)
		{
			return 1;
		}
		if(fp == NULL)
		{
			return 1;
		}
		if((mode & FILEMODE_MASK) == FILEMODE_MZT)
		{
			MZTHEAD mzthead;
			// ヘッダ情報作成
			memset(&mzthead, 0, sizeof(MZTHEAD));
			mzthead.mode = this->directory[dirindex].mode;
			memcpy(mzthead.filename, this->directory[dirindex].filename, 17 );
			mzthead.size = this->directory[dirindex].size;
			mzthead.loadAdr = this->directory[dirindex].loadAdr;
			mzthead.runAdr = this->directory[dirindex].runAdr;
			// ヘッダ情報書き込み
			fwrite(&mzthead, 1, 128, fp);
		}
		// データ書き込み
		if(this->directory[dirindex].mode == FILETYPE_BSD)
		{
			int sector;
			int rest;
			sector = this->directory[dirindex].startSector;
			rest = this->directory[dirindex].size;
			while(sector != 0)
			{
				std::vector<unsigned char> buffer;
				ReadSector(buffer, sector, 1);
				if(rest > 254)
				{
					fwrite(&buffer[0], 1, 254, fp);
				}
				else
				{
					fwrite(&buffer[0], 1, rest, fp);
					break;
				}
				sector = static_cast<int>(buffer[254]) + static_cast<int>(buffer[255]) * 256;
				rest -= 254;
			}
		}
		else if(this->directory[dirindex].mode == FILETYPE_BRD)
		{
			int sector;
			int rest;
			int sectorIndex = 0;
			sector = this->directory[dirindex].startSector;
			rest = this->directory[dirindex].size * 32;
			std::vector<unsigned char> sectorListBuffer;
			ReadSector(sectorListBuffer, sector, 1);
			unsigned short* sectorList = reinterpret_cast<unsigned short*>(&sectorListBuffer[0]);
			sector = sectorList[sectorIndex];
			while(sector != 0)
			{
				std::vector<unsigned char> buffer;
				ReadSector(buffer, sector, 16);
				if(rest > 4096)
				{
					fwrite(&buffer[0], 1, 4096, fp);
				}
				else
				{
					fwrite(&buffer[0], 1, rest, fp);
					break;
				}
				++ sectorIndex;
				sector = sectorList[sectorIndex];
				rest -= 4096;
			}
		}
		else
		{
			std::vector<unsigned char> buffer;
			int sectorCount = (this->directory[dirindex].size + this->sectorSize - 1) / this->sectorSize;
			ReadSector(buffer, this->directory[dirindex].startSector, sectorCount);
			fwrite(&buffer[0], 1, this->directory[dirindex].size, fp);
		}
		// 書き込み終了
		fclose(fp);
		return 0;
	}
	catch(const std::exception& error)
	{
		(void)error;
		return 1;
	}
}

//============================================================================
//  ディスクイメージにファイルを書き込む
//----------------------------------------------------------------------------
// In  : path = ファイル名
//     : dirinfo = ディレクトリ情報
//     : mode = ファイルモード
//     :   FILEMODE_MZT
//     :   FILEMODE_BIN
//     :   FILEMODE_NEWLINE_CONV
//     : type = ファイルタイプ
//     :   FILETYPE_OBJ = 1
//     :   FILETYPE_BTX = 2
//     :   FILETYPE_BSD = 3
//     :   FILETYPE_BRD = 4
//     :   FILETYPE_BSD_CONV = 5
// Out : 0 = 正常終了
//============================================================================
int MzDisk::PutFile(std::string path, void* dirInfo, unsigned int mode, unsigned int type)
{
	try
	{
		DIRECTORY* dirinfo = reinterpret_cast<DIRECTORY*>(dirInfo);
		// ディレクトリ検索
		int select = -1;
		for(int i = 0; i < 64; ++ i)
		{
			if(this->directory[i].mode == 0)
			{
				select = i;
				break;
			}
		}
		if(select == -1)
		{
			// ディレクトリに空きがありません
			return 1;
		}
		// ファイルを読み込む
		FILE* fp;
		if(fopen_s(&fp, path.c_str(), "rb") != 0)
		{
			// ファイルを読み込むことができない
			return 2;
		}
		if(fp == NULL)
		{
			// ファイルを読み込むことができない
			return 2;
		}
		// ファイルサイズ取得
		fseek(fp, 0, SEEK_END);
		size_t dataSize = ftell(fp);
		fseek(fp, 0, SEEK_SET);
		MZTHEAD mzthead;
		if(mode == FILEMODE_MZT)
		{
			if(dataSize <= 128)
			{
				// ファイルサイズが足りない
				return 3;
			}
			dataSize -= 128;	// ヘッダを除いたデータサイズ
			// ヘッダ情報作成
			memset(&mzthead, 0, sizeof(MZTHEAD));
			fread(&mzthead, 128, 1, fp);
		}
		// 同じファイル名が無いかチェックする
		char filename[18];
		memset(filename, 0, sizeof(filename));
		if((mode == FILEMODE_MZT) && (dirinfo == NULL))
		{
			memcpy(filename, mzthead.filename, 17);
		}
		else
		{
			memcpy(filename, dirinfo->filename, 17);
		}
		for(int i = 0; i < 17; ++ i)
		{
			if(filename[i] == 0x0D)
			{
				filename[i] = '\0';
			}
		}
		for(int i = 0; i < 64; ++ i)
		{
			if(this->directory[i].mode != 0)
			{
				// ファイル名の長さが同じ?
				if(strlen(this->directory[i].filename) == strlen(filename))
				{
					// ファイルネームが同じ?
					if(strncmp(this->directory[i].filename, filename, strlen(filename)) == 0)
					{
						// 同じファイル名が存在する
						return 5;
					}
				}
			}
		}
		// ファイルデータを読み込む
		size_t readSize = (dataSize + this->sectorSize - 1) / this->sectorSize * this->sectorSize;
		std::vector<unsigned char> bufferTemp;
		bufferTemp.resize(readSize, 0);
		fread(&bufferTemp[0], 1, dataSize, fp);
		fclose(fp);
		if(type == FILETYPE_BSD_CONV)
		{
			ConvertBsdFile(dirinfo, mode, type, readSize, dataSize, bufferTemp);
		}
		if(type == FILETYPE_BSD)
		{
			if(PutBsdFile(dirinfo, mode, mzthead, select, dataSize, bufferTemp) == false)
			{
				// ビットマップの空き容量が無い
				return 4;
			}
		}
		else if(type == FILETYPE_BRD)
		{
			if(PutBrdFile(dirinfo, mode, mzthead, select, dataSize, bufferTemp) == false)
			{
				// ビットマップの空き容量が無い
				return 4;
			}
		}
		else
		{
			if(PutObjFile(dirinfo, mode, mzthead, select, dataSize, bufferTemp, type) == false)
			{
				// ビットマップの空き容量が無い
				return 4;
			}
		}
		// 管理情報をD88イメージに書き込み
		FlushWrite();
		return 0;
	}
	catch(const std::exception& error)
	{
		(void)error;
		return 1;
	}
}

void MzDisk::ConvertBsdFile(DIRECTORY *dirinfo, unsigned int mode, unsigned int& type, size_t readSize, size_t dataSize, std::vector<unsigned char>& bufferTemp)
{
	if(mode != FILEMODE_MZT)
	{
		int back = -1;
		std::vector<unsigned char> convTemp;
		convTemp.resize(dataSize, 0);
		int j = 0;
		for(int i = 0; i < dataSize; ++ i)
		{
			// CRLFの場合はLFを消す
			if((bufferTemp[i] == 0x0A) && (back == 0x0D))
			{
				back = bufferTemp[i];
				continue;
			}
			unsigned char data = bufferTemp[i];
			// LFの場合はCRにする
			if((bufferTemp[i] == 0x0A) && (back != 0x0D))
			{
				data = 0x0D;
			}
			convTemp[j] = data;
			++ j;
			back = bufferTemp[i];
		}
		dataSize = j;
		bufferTemp.clear();
		std::copy(convTemp.begin(), convTemp.end(), std::back_inserter(bufferTemp));
		if(dirinfo != 0)
		{
			dirinfo->size = static_cast<unsigned short>(dataSize);
		}
	}
	type = FILETYPE_BSD;
}

bool MzDisk::PutBsdFile(DIRECTORY *dirinfo, unsigned int mode, MZTHEAD& mzthead, int select, size_t dataSize, std::vector<unsigned char>& bufferTemp)
{
	if(GetBitmapSize() < dataSize)
	{
		return false;
	}
	// ファイル情報をディレクトリに登録
	int rest;
	if((FILEMODE_MZT == mode) && (dirinfo == NULL))
	{
		memset(&this->directory[select], 0, 32);
		this->directory[select].mode = mzthead.mode;
		memcpy(this->directory[select].filename, mzthead.filename, 17);
		this->directory[select].attr = 0;
		this->directory[select].size = mzthead.size;
		this->directory[select].loadAdr = mzthead.loadAdr;
		this->directory[select].runAdr = mzthead.runAdr;
		this->directory[select].date = 0;
		rest = mzthead.size;
	}
	else
	{
		memcpy(&this->directory[select], dirinfo, 32);
		rest = dirinfo->size;
	}
	int temp = this->bitmap[2] + this->bitmap[3] * 256;
	int datacluster = ((static_cast<int>(dataSize) + this->clusterSize - 1) / this->clusterSize);
	this->bitmap[2] = (temp + datacluster) & 255;
	this->bitmap[3] = ((temp + datacluster) / 256) & 255;
	// ファイルをディスクイメージに転送
	int before = -1;
	int cluster = GetBitmap();
	this->directory[select].startSector = (this->bitmap[1] + cluster) * this->clusterSize / this->sectorSize;
	unsigned char* source = &bufferTemp[0];
	std::vector<unsigned char> writeBuffer;
	writeBuffer.resize(this->sectorSize, 0);
	while(rest > 0)
	{
		cluster = GetBitmap();
		SetBitmap(cluster, 1);
		int sector = ((this->bitmap[1] + cluster) * this->clusterSize) / this->sectorSize;
		for(int i = 0; i < ( this->clusterSize / this->sectorSize ); ++ i)
		{
			int write_size;
			write_size = rest;
			if(rest > this->sectorSize - 2)
			{
				write_size = this->sectorSize - 2;
			}
			memset(&writeBuffer[0], 0, this->sectorSize);
			memcpy(&writeBuffer[0], source, write_size);
			WriteSector(writeBuffer, sector, 1);
			if(before != -1)
			{
				std::vector<unsigned char> beforeBuffer;
				ReadSector(beforeBuffer, before, 1);
				beforeBuffer[static_cast<size_t>(this->sectorSize) - 2] = sector % 256;
				beforeBuffer[static_cast<size_t>(this->sectorSize) - 1] = sector / 256;
				WriteSector(beforeBuffer, before, 1);
			}
			rest -= write_size;
			if( rest <= 0 )
			{
				break;
			}
			source += (static_cast<size_t>(this->sectorSize) - 2);
			before = sector;
			++ sector;
		}
	}
	return true;
}

bool MzDisk::PutBrdFile(DIRECTORY *dirinfo, unsigned int mode, MZTHEAD& mzthead, int select, size_t dataSize, std::vector<unsigned char>& bufferTemp)
{
	if(GetBitmapSize() < dataSize)
	{
		return false;
	}
	// ファイル情報をディレクトリに登録
	int rest;
	if((mode == FILEMODE_MZT) && (dirinfo == NULL))
	{
		memset(&this->directory[select], 0, 32);
		this->directory[select].mode = mzthead.mode;
		memcpy(this->directory[select].filename, mzthead.filename, 17);
		this->directory[select].attr = 0;
		this->directory[select].size = ((mzthead.size + 4095) / 4096 * 4096) / 32;
		this->directory[select].loadAdr = mzthead.loadAdr;
		this->directory[select].runAdr = mzthead.runAdr;
		this->directory[select].date = 0;
		rest = mzthead.size;
	}
	else
	{
		memcpy(&this->directory[select], dirinfo, 32);
		rest = static_cast<int>(dirinfo->size) * 32;
	}
	int temp = this->bitmap[2] + this->bitmap[3] * 256;
	int datacluster = ((static_cast<int>(dataSize) + this->clusterSize - 1) / this->clusterSize);
	this->bitmap[ 2 ] = (temp + datacluster) & 255;
	this->bitmap[ 3 ] = ((temp + datacluster) / 256) & 255;
	// ファイルをディスクイメージに転送
	int cluster = GetBitmapSerial(256);
	this->directory[select].startSector = (this->bitmap[1] + cluster) * this->clusterSize / this->sectorSize;
	SetBitmap(cluster, 1);
	std::vector<unsigned short> sectorList;
	std::vector<unsigned char> writeBuffer;
	unsigned char* source = &bufferTemp[0];
	while(rest > 0)
	{
		unsigned short sector;
		int loop;
		// 4KByte単位で連続した領域を取得する
		cluster = GetBitmapSerial(4096);
		if(this->clusterSize <= 4096)
		{
			SetBitmap(cluster, 4096 / this->clusterSize);
			loop = 1;
		}
		else
		{
			SetBitmap(cluster, 1);
			loop = this->clusterSize / 4096;
		}
		sector = ((this->bitmap[1] + cluster) * this->clusterSize) / this->sectorSize;
		for(int i = 0; i < loop; ++ i)
		{
			int write_size;
			write_size = rest;
			if(rest > 4096)
			{
				write_size = 4096;
			}
			int writeSectorCount = (write_size + this->sectorSize - 1)/ this->sectorSize;
			writeBuffer.clear();
			std::copy(source, source + write_size, std::back_inserter(writeBuffer));
			WriteSector(writeBuffer, sector, writeSectorCount);
			sectorList.push_back(sector);
			rest -= write_size;
			if(rest <= 0)
			{
				break;
			}
			source += 4096;
			sector += (4096 / this->sectorSize);
		}
	}
	writeBuffer.clear();
	writeBuffer.resize(this->sectorSize, 0);
	unsigned char* copyBuffer = reinterpret_cast<unsigned char*>(&sectorList[0]);
	size_t coptBytes = sectorList.size() * sizeof(unsigned short);
	std::copy(copyBuffer, copyBuffer + coptBytes, writeBuffer.begin());
	WriteSector(writeBuffer, this->directory[select].startSector, 1);
	return true;
}

bool MzDisk::PutObjFile(DIRECTORY *dirinfo, unsigned int mode, MZTHEAD& mzthead, int select, size_t dataSize, std::vector<unsigned char>& bufferTemp, unsigned int type)
{
	// ビットマップ検索
	int freespace = GetBitmapSerial(static_cast<int>(dataSize));
	if(freespace == -1)
	{
		// ビットマップの空き容量が無い
		return false;
	}
	int size = 0;
	// ファイル情報をディレクトリに登録
	if((mode == FILEMODE_MZT) && (dirinfo == NULL))
	{
		memset(&this->directory[select], 0, 32);
		this->directory[select].mode = mzthead.mode;
		memcpy(this->directory[select].filename, mzthead.filename, 17);
		this->directory[select].attr = 0;
		this->directory[select].size = mzthead.size;
		this->directory[select].loadAdr = mzthead.loadAdr;
		this->directory[select].runAdr = mzthead.runAdr;
		this->directory[select].date = 0;
		size = mzthead.size;
	}
	else
	{
		memcpy(&this->directory[select], dirinfo, 32);
		size = dirinfo->size;
	}
	int temp = this->bitmap[2] + this->bitmap[3] * 256;
	int datacluster = ((static_cast<int>(dataSize) + this->clusterSize - 1) / this->clusterSize);
	this->bitmap[2] = (temp + datacluster) & 255;
	this->bitmap[3] = ((temp + datacluster) / 256) & 255;
	this->directory[select].startSector = (this->bitmap[1] + freespace) * (this->bitmap[255] + 1);
	// ビットマップ更新
	SetBitmap(freespace, datacluster);
	// ファイルをディスクイメージに転送
	std::vector<unsigned char> writeBuffer;
	int writeSector = (this->bitmap[1] + freespace) * this->clusterSize / this->sectorSize;
	int writeSectorCount = (size + this->sectorSize - 1) / this->sectorSize;
	writeBuffer.resize(static_cast<size_t>(writeSectorCount) * this->sectorSize, 0);
	std::copy(bufferTemp.begin(), bufferTemp.end(), writeBuffer.begin());
	WriteSector(writeBuffer, writeSector, writeSectorCount);
	return true;
}

//============================================================================
//  ディスクイメージのファイルを削除する
//----------------------------------------------------------------------------
// In  : dirindex = ディレクトリ番号
// Out : 0 = 正常終了
//============================================================================
int MzDisk::DelFile(int dirindex)
{
	if(this->directory[dirindex].mode == 0)
	{
		return 1;
	}
	if(this->directory[dirindex].mode == FILETYPE_BSD)
	{
		DelBsdFile(dirindex);
	}
	else if(this->directory[dirindex].mode == FILETYPE_BRD)
	{
		DelBrdFile(dirindex);
	}
	else
	{
		DelObjFile(dirindex);
	}
	this->directory[dirindex].mode = 0;
	// 管理情報をD88イメージに書き込み
	FlushWrite();
	return 0;
}

// BSDファイル削除
void MzDisk::DelBsdFile(int dirindex)
{
	int sector = this->directory[dirindex].startSector;
	while(sector > 0)
	{
		int start = sector / (this->bitmap[255] + 1) - this->bitmap[1];
		DelBitmap(start, 1);
		std::vector<unsigned char> buffer;
		ReadSector(buffer, sector, 1);
		sector = static_cast<int>(buffer[254]) + static_cast<int>(buffer[255]) * 256;
	}
}

// BRDファイル削除
void MzDisk::DelBrdFile(int dirindex)
{
	int sector = this->directory[dirindex].startSector;
	std::vector<unsigned char> sectorListBuffer;
	ReadSector(sectorListBuffer, sector, 1);
	int start = sector / (this->bitmap[255] + 1) - this->bitmap[1];
	DelBitmap(start, 1);
	unsigned short* sectorList = reinterpret_cast<unsigned short*>(&sectorListBuffer[0]);
	int sectorIndex = 0;
	int size = 4096 / this->clusterSize;
	while(sectorList[sectorIndex] > 0)
	{
		int start = sectorList[sectorIndex] / (this->bitmap[255] + 1) - this->bitmap[1];
		DelBitmap(start, size);
		++ sectorIndex;
	}
}

// BTX or OBJファイル削除
void MzDisk::DelObjFile(int dirindex)
{
	int start = this->directory[dirindex].startSector / (this->bitmap[255] + 1) - this->bitmap[1];
	int size = (this->directory[dirindex].size + this->clusterSize - 1) / this->clusterSize;
	DelBitmap(start, size);
}

//============================================================================
//  ディスクイメージからブートプログラムを取り出す
//----------------------------------------------------------------------------
// In  : path = 保存位置
//     : mode = ファイルモード
// Out : 0 = 正常終了
//============================================================================
int MzDisk::GetBoot(std::string path, unsigned int mode)
{
	std::vector<unsigned char> iplBuffer;
	ReadSector(iplBuffer, 0, 1);
	IPL* ipl = reinterpret_cast<IPL*>(&iplBuffer[0]);
	if(strncmp(ipl->signature, "IPLPRO", 6) != 0)
	{
		// 起動ディスクではありません
		return 1;
	}
	FILE *fp;
	if(fopen_s(&fp, path.c_str(), "wb") != 0)
	{
		return 1;
	}
	if(fp == NULL)
	{
		return 1;
	}
	if((mode & FILEMODE_MASK) == FILEMODE_MZT)
	{
		// ヘッダ情報作成
		MZTHEAD mzthead;
		memset(&mzthead, 0, sizeof(MZTHEAD));
		mzthead.mode = 1;
		memcpy(mzthead.filename, ipl->bootname, 11);
		for(int i = 0; i < 17; ++ i)
		{
			if(mzthead.filename[i] == 0)
			{
				mzthead.filename[i] = '\xD';
				break;
			}
		}
		mzthead.size = ipl->size;
		// ヘッダ情報書き込み
		fwrite(&mzthead, 1, 128, fp);
	}
	// データ書き込み
	int writesize = ipl->size;
	if(writesize == 0)
	{
		writesize = 65536;
	}
	std::vector<unsigned char> writeBuffer;
	int sectorSize = (writesize + this->sectorSize - 1) / this->sectorSize;
	ReadSector(writeBuffer, ipl->startSector, sectorSize);
	fwrite(&writeBuffer[0], 1, writesize, fp);
	// 書き込み終了
	fclose( fp );
	return 0;
}

//============================================================================
//  ディスクイメージにブートプログラムを書き込む
//----------------------------------------------------------------------------
// In  : path = ファイル名
//     : iplinfo = ディレクトリ情報
//     : mode = ファイルモード
//     :   FILEMODE_MZT
//     :   FILEMODE_BIN
//     : machine = 機種
//     :   01h MZ-80B/2000/2200
//     :   02h MZ-80A
//     :   03h MZ-700/1500
// Out : 0 = 正常終了
//============================================================================
int MzDisk::PutBoot(std::string path, void* iplInfo, unsigned int mode, unsigned char machine)
{
	IPL* iplinfo = reinterpret_cast<IPL*>(iplInfo);
	std::vector<unsigned char> iplBuffer;
	ReadSector(iplBuffer, 0, 1);
	IPL* ipl = reinterpret_cast<IPL*>(&iplBuffer[0]);
	// ファイルを読み込む
	FILE *fp;
	if(fopen_s(&fp, path.c_str(), "rb") != 0)
	{
		return 1;
	}
	if(fp == NULL)
	{
		// ファイルを読み込むことができない
		return 1;
	}
	// ファイルサイズ取得
	fseek(fp, 0, SEEK_END);
	int datasize = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	MZTHEAD mzthead;
	if(mode == FILEMODE_MZT)
	{
		if(datasize <= 128)
		{
			// ファイルサイズが足りない
			return 2;
		}
		datasize -= 128;	// ヘッダを除いたデータサイズ
		// ヘッダ情報作成
		memset(&mzthead, 0, sizeof(MZTHEAD));
		fread(&mzthead, 128, 1, fp);
	}
	// ファイルデータを読み込む
	int fileSectorCount = (datasize + this->sectorSize - 1) / this->sectorSize;
	int fileBufferSize = fileSectorCount * this->sectorSize;
	std::vector<unsigned char> bufferFile;
	bufferFile.resize(fileBufferSize, 0);
	fread(&bufferFile[0], 1, datasize, fp);
	fclose(fp);
	// ビットマップ検索
	int freeSpace = GetBitmapSerial(datasize);
	if(freeSpace == -1)
	{
		// ビットマップの空き容量が無い
		return 4;
	}
	// ファイル情報をディレクトリに登録
	if((mode == FILEMODE_MZT) && (iplinfo == NULL))
	{
		memset(ipl, 0, 32);
		ipl->machine = machine;
		memcpy(ipl->bootname, mzthead.filename, 10);
		ipl->bootname[10] = '\xD';
		ipl->size = mzthead.size;
		ipl->runAdr = mzthead.runAdr;
	}
	else
	{
		memcpy(ipl, iplinfo, 32);
		ipl->size = datasize;
	}
	ipl->signature[0] = 'I';
	ipl->signature[1] = 'P';
	ipl->signature[2] = 'L';
	ipl->signature[3] = 'P';
	ipl->signature[4] = 'R';
	ipl->signature[5] = 'O';
	int usedCluster = this->bitmap[2] + this->bitmap[3] * 256;
	int dataCluster = (datasize + this->clusterSize - 1) / this->clusterSize;
	this->bitmap[2] = (usedCluster + dataCluster) & 255;
	this->bitmap[3] = ((usedCluster + dataCluster) / 256) & 255;
	ipl->startSector = (this->bitmap[1] + freeSpace) * (this->bitmap[255] + 1);
	ipl->master = 0xFF; // マスターディスク
	// ビットマップ更新
	SetBitmap(freeSpace, dataCluster);
	// IPLをディスクイメージに転送
	WriteSector(iplBuffer, 0, 1);
	// ファイルをディスクイメージに転送
	WriteSector(bufferFile, ipl->startSector, fileSectorCount);
	FlushWrite();
	return 0;
}

//============================================================================
//  ディスクイメージからしててむプログラムを取り出す(MZ-80K専用)
//----------------------------------------------------------------------------
// In  : path = 保存位置
//     : mode = ファイルモード
// Out : 0 = 正常終了
//============================================================================
int MzDisk::GetSystem(std::string path, unsigned int mode)
{
	return 1;
}

//============================================================================
//  ディスクイメージにシステムプログラムを書き込む(MZ-80K専用)
//----------------------------------------------------------------------------
// In  : path = ファイル名
//     : mode = ファイルモード
//     :   FILEMODE_MZT
//     :   FILEMODE_BIN
// Out : 0 = 正常終了
//============================================================================
int MzDisk::PutSystem(std::string path, void* iplInfo, unsigned int mode)
{
	return 1;
}

//============================================================================
//  ビットマップから空き領域を検索する
//----------------------------------------------------------------------------
// Out : 空きサイズ
//============================================================================
int MzDisk::GetBitmapSize(void)
{
	int freesize = 0;
	unsigned char bit;
	int end;
	end = this->bitmap[4] + this->bitmap[5] * 256;
	for(int i = 48; i < end; ++ i)
	{
		bit = (this->bitmap[i / 8] >> (i % 8)) & 1;
		if(bit == 0)
		{
			freesize ++;
		}
	}
	return freesize * this->clusterSize;
}

//============================================================================
//  ビットマップから空き領域を検索する
//----------------------------------------------------------------------------
// Out : 空きサイズ
//============================================================================
int MzDisk::GetBitmap(void)
{
	unsigned char bit;
	int end;
	end = this->bitmap[4] + this->bitmap[5] * 256;
	for(int i = 48; i < end; ++ i)
	{
		bit = (this->bitmap[i / 8] >> (i % 8)) & 1;
		if(bit == 0)
		{
			return i - 48;
		}
	}
	return -1;
}

//============================================================================
//  ビットマップから連続空き領域を検索する
//----------------------------------------------------------------------------
// In  : length = 書き込み長 (Byte)
// Out : 空き位置格納領域
//============================================================================
int MzDisk::GetBitmapSerial(int length)
{
	int lengthtemp = 0;
	unsigned char bit;
	int index = -1;
	int end;
	int length_cluster;
	length_cluster = (length + this->clusterSize - 1) / this->clusterSize;
	end = this->bitmap[4] + this->bitmap[5] * 256;
	for(int i = 48; i < end; ++ i)
	{
		bit = (this->bitmap[i / 8] >> (i % 8)) & 1;
		if(bit == 0)
		{
			if(index == -1)
			{
				index = i;
			}
			lengthtemp ++;
			if(lengthtemp >= length_cluster)
			{
				index -= 48;
				break;
			}
		}
		else
		{
			lengthtemp = 0;
			index = -1;
		}
	}
	return index;
}

//============================================================================
//  ビットマップを設定する
//----------------------------------------------------------------------------
// In  : start = 位置
//     : length = 長さ (length ビット)
// Out : なし
//============================================================================
void MzDisk::SetBitmap(int start, int length)
{
	unsigned char* data;
	start += 48;
	for(int i = start; i < (start + length); ++ i)
	{
		data = &this->bitmap[i / 8];
		*data |= (1 << (i % 8));
	}
	WriteUseSize();
}

//============================================================================
//  ビットマップを開放する
//----------------------------------------------------------------------------
// In  : start = 位置
//     : length = 長さ (length ビット)
// Out : なし
//============================================================================
void MzDisk::DelBitmap(int start, int length)
{
	unsigned char* data;
	start += 48;
	for(int i = start; i < (start + length); ++ i)
	{
		data = &this->bitmap[i / 8];
		*data &= (~(1 << (i % 8)));
	}
	WriteUseSize();
}

// MZ-80B/2000の文字をWindowsで使える文字に変換する
// MZ-2500のディスクの時に誤変換してしまうので一旦使わないようにした
std::string MzDisk::ConvertText(std::string text)
{
	std::string result;
	bool kanji = false;
	for(size_t i = 0; i < text.size(); ++ i)
	{
		if(kanji == true)
		{
			// 漢字の2バイト目
			result += text[i];
			kanji = false;
		}
		else if((this->diskType != DISKTYPE_MZ80A_2D35) && (IsKanji(static_cast<unsigned char>(text[i]))))
		{
			// 漢字の1バイト目
			result += text[i];
			kanji = true;
		}
		else if(IsNotAvailableFileCharacter(text[i]) == true)
		{
			// ファイル名に使えない文字
			result += "_";
		}
		else
		{
			std::string ascii;
			std::string sjis;
			int asciiIndex = static_cast<unsigned char>(text[i]) - 0x20;
			int index = asciiIndex * 2;
			if(this->diskType == DISKTYPE_MZ80A_2D35)
			{
				ascii.push_back(asciiCodeAnk80A[asciiIndex]);
				sjis.push_back(asciiCodeSjis80A[index]);
				sjis.push_back(asciiCodeSjis80A[index + 1]);
			}
			else
			{
				ascii.push_back(asciiCodeAnk[asciiIndex]);
				sjis.push_back(asciiCodeSjis[index]);
				sjis.push_back(asciiCodeSjis[index + 1]);
			}
			if((text[i] == '_') || (ascii == ".") && (sjis == "※"))
			{
				result += "_";
			}
// ファイル取り出し時に拡張子があると例外エラーになるので廃止
//			else if((ascii == ".") && (sjis != "※"))
//			{
//				result += sjis;
//			}
			else
			{
				result += ascii;
			}
		}
	}
	return result;
}

// Windowsの文字をMZで使える文字に変換する
std::string MzDisk::ConvertMzText(std::string text)
{
	std::string result = "";
	bool kanji = false;
	std::string word = "";
	for(size_t i = 0; i < text.size(); ++ i)
	{
		if(IsKanji(text[i]))
		{
			word.push_back(text[i]);
			kanji = true;
			continue;
		}
		else
		{
			word.push_back(text[i]);
		}
		if(kanji == true)
		{
//@@			std::string a;
			size_t l = strlen(asciiCodeSjis);
			size_t findIndex;
			if(this->diskType == DISKTYPE_MZ80A_2D35)
			{
				findIndex = std::string(asciiCodeSjis80A).find(word);
				//a.push_back(asciiCodeSjis80A[findIndex]);
				//a.push_back(asciiCodeSjis80A[findIndex + 1]);
			}
			else
			{
				findIndex = std::string(asciiCodeSjis).find(word);
				//a.push_back(asciiCodeSjis[findIndex]);
				//a.push_back(asciiCodeSjis[findIndex + 1]);
			}
			if(findIndex != std::string::npos)
			{
				// 全角文字が見つかった
				word = "";
				word.push_back(static_cast<char>(findIndex / 2 + 0x20));
			}
			else
			{
				word = "";
			}
		}
		else
		{
			size_t findIndex = std::string(asciiCodeAnk).find(word);
			if(findIndex != std::string::npos)
			{
				// 半角文字が見つかった
				word = "";
				word.push_back(static_cast<char>(findIndex + 0x20));
			}
			else
			{
				word = "";
			}
		}
		result += word;
		word = "";
		kanji = false;
	}
	return result;
}

//============================================================================
//  ファイルを検索する
//----------------------------------------------------------------------------
// In  : path: ファイル名
// Out : -1: なし, 0〜: ファイルがあるディレクトリのインデックス
//============================================================================
int MzDisk::FindFile(std::string filename, int ignoreIndex)
{
	for(int i = 0; i < 64; ++ i)
	{
		if(this->directory[i].mode != 0)
		{
			size_t directryFileLength = 0;
			for(size_t j = 0; j < 17; ++ j)
			{
				if(this->directory[i].filename[j] == 0x0D)
				{
					break;
				}
				++ directryFileLength;
			}
			size_t fileLength = filename.size();
			// ファイル名の長さが同じ
			if(directryFileLength == fileLength)
			{
				// ファイルネーム
				if((strncmp(this->directory[i].filename, &filename[0], filename.size()) == 0) && (i != ignoreIndex))
				{
					// 同じファイル名が存在する
					return i;
				}
			}
		}
	}
	return -1;
}

//============================================================================
//  ディスクのタイプを取得する
//----------------------------------------------------------------------------
// In  : なし
// Out : TYPE_2D: 2Dに変更する, TYPE_2DD: 2DDに変更する
//============================================================================
int MzDisk::GetType(void)
{
	return this->mediaType;
}

//============================================================================
//  ディスクのタイプを変更する
//----------------------------------------------------------------------------
// In  : type: TYPE_2D: 2Dに変更する, TYPE_2DD: 2DDに変更する
// Out : なし
//============================================================================
void MzDisk::ChangeType(int type)
{
	if(this->mediaType == type)
	{
		return;
	}
	unsigned char diskType = (type == 0) ? TYPE_2D : TYPE_2DD;
	D88Image::Header header;
	this->image.GetHeader(header);
	header.diskType = diskType;
	int trackMax = 0;
	for(int i = 0; i < D88Image::TRACK_COUNT; ++ i)
	{
		if(header.trackTable[i] != 0)
		{
			++ trackMax;
		}
	}
	this->mediaType = diskType;
}

//============================================================================
//  IPLセレクタを登録する
//----------------------------------------------------------------------------
// MZ-80Kでは未使用
//============================================================================
void MzDisk::PutIplSelector(std::string path)
{
	dms::FileData fileData;
	std::vector<unsigned char> buffer;
	try
	{
		fileData.Load(path.c_str());
		fileData.GetBuffer(buffer);
	}
	catch (const std::exception& error)
	{
		(void)error;
		static const unsigned char iplSelectorImage[] =
		{
			0x01, 0x49, 0x50, 0x4C, 0x50, 0x52, 0x4F, 0x49, 0x50, 0x4C, 0x53, 0x30, 0x39, 0x62, 0x4B, 0x61,
			0x69, 0x0D, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
			0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0x02, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xF3, 0x3E, 0x82, 0xD3, 0xE3, 0x3E, 0x58, 0xD3, 0xE2, 0x3E, 0x0F, 0xD3, 0xE9, 0x3E, 0xCF, 0xD3,
			0xEB, 0x3E, 0xFF, 0xD3, 0xEB, 0x21, 0x00, 0x50, 0x36, 0x20, 0xDB, 0xE8, 0xE6, 0xDF, 0xF6, 0xC0,
			0xD3, 0xE8, 0x36, 0x38, 0xDB, 0xE8, 0xE6, 0x3F, 0xD3, 0xE8, 0x7E, 0xFE, 0x38, 0x20, 0x1A, 0x3E,
			0x32, 0x32, 0x00, 0xFF, 0x3E, 0xF7, 0xD3, 0xE0, 0xAF, 0xD3, 0xF6, 0xD3, 0xF4, 0x3E, 0x07, 0xD3,
			0xF5, 0x21, 0x00, 0xD0, 0x22, 0x02, 0xFF, 0x18, 0x3A, 0x3E, 0x38, 0x32, 0x00, 0xFF, 0x3E, 0x12,
			0xD3, 0xE0, 0xAF, 0xD3, 0xF4, 0x21, 0x00, 0x50, 0x22, 0x02, 0xFF, 0x18, 0x26, 0xF3, 0x3E, 0x35,
			0x32, 0x00, 0xFF, 0x3E, 0x0F, 0xD3, 0xC8, 0xDB, 0xC9, 0xCB, 0x77, 0x28, 0x0B, 0x3E, 0x4C, 0x32,
			0x01, 0xFF, 0x3E, 0x01, 0xD3, 0xF7, 0x18, 0x05, 0x3E, 0x48, 0x32, 0x01, 0xFF, 0x21, 0x00, 0xC0,
			0x22, 0x02, 0xFF, 0x31, 0x00, 0x00, 0x21, 0x00, 0x01, 0x11, 0x00, 0xF2, 0x01, 0x00, 0x0D, 0xED,
			0xB0, 0xC3, 0x00, 0xF2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x21, 0x00, 0x00, 0xCD, 0x10, 0xF6, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0x20, 0x2E, 0xAF, 0xD3, 0xB4,
			0xD3, 0xB5, 0x3A, 0x4A, 0x08, 0xFE, 0x46, 0x28, 0x03, 0xAF, 0x18, 0x03, 0x3A, 0x46, 0x08, 0x32,
			0x14, 0xFF, 0xAF, 0xD3, 0xB4, 0x3E, 0x02, 0xD3, 0xB5, 0x3E, 0x5F, 0x32, 0xBB, 0xFE, 0x32, 0xBD,
			0xFE, 0x3E, 0x0D, 0x32, 0xC0, 0xFE, 0x11, 0x21, 0xF7, 0x18, 0x12, 0x3A, 0xEC, 0x7F, 0x32, 0x14,
			0xFF, 0xFE, 0x38, 0x20, 0x05, 0x11, 0xCF, 0xF6, 0x18, 0x03, 0x11, 0xF8, 0xF6, 0x21, 0x00, 0x00,
			0x01, 0x28, 0x00, 0xCD, 0xEF, 0xFD, 0x11, 0x4A, 0xF7, 0x21, 0x28, 0x00, 0x01, 0x28, 0x00, 0xCD,
			0xEF, 0xFD, 0x11, 0xD8, 0xF7, 0x3A, 0xFF, 0x0E, 0xFE, 0x00, 0x20, 0x08, 0x3E, 0x46, 0x32, 0x8C,
			0xFC, 0x11, 0xF6, 0xF7, 0x21, 0x78, 0x00, 0x01, 0x28, 0x00, 0xCD, 0xEF, 0xFD, 0x01, 0xC0, 0x03,
			0x21, 0x00, 0x80, 0x36, 0x20, 0x23, 0x0B, 0x78, 0xB1, 0x20, 0xF8, 0xCD, 0x17, 0xFC, 0xAF, 0x32,
			0x04, 0xFF, 0x32, 0x05, 0xFF, 0x21, 0x20, 0x0F, 0x22, 0x06, 0xFF, 0x11, 0x00, 0x80, 0xED, 0x53,
			0x08, 0xFF, 0x2A, 0x06, 0xFF, 0x7E, 0xFE, 0x01, 0x20, 0x39, 0x2A, 0x06, 0xFF, 0xED, 0x5B, 0x08,
			0xFF, 0x01, 0x20, 0x00, 0xED, 0xB0, 0x3A, 0x04, 0xFF, 0x3C, 0x32, 0x04, 0xFF, 0xC6, 0x40, 0x2A,
			0x08, 0xFF, 0x77, 0x23, 0x36, 0x3A, 0x23, 0xE5, 0x2A, 0x06, 0xFF, 0x23, 0xD1, 0x01, 0x11, 0x00,
			0xED, 0xB0, 0x2A, 0x08, 0xFF, 0x11, 0x20, 0x00, 0x19, 0x22, 0x08, 0xFF, 0x3A, 0x04, 0xFF, 0xFE,
			0x1A, 0x28, 0x16, 0x2A, 0x06, 0xFF, 0x11, 0x20, 0x00, 0x19, 0x22, 0x06, 0xFF, 0x3A, 0x05, 0xFF,
			0xC6, 0x01, 0x32, 0x05, 0xFF, 0xFE, 0x3C, 0x20, 0xA9, 0xAF, 0x32, 0x0A, 0xFF, 0x21, 0x04, 0xFF,
			0xBE, 0xCA, 0x1F, 0xF5, 0x21, 0x00, 0x80, 0x22, 0x0C, 0xFF, 0x11, 0xCA, 0x00, 0xED, 0x53, 0x0E,
			0xFF, 0x2A, 0x0C, 0xFF, 0x7E, 0xFE, 0x20, 0x28, 0x38, 0x2A, 0x0E, 0xFF, 0xED, 0x5B, 0x0C, 0xFF,
			0x01, 0x13, 0x00, 0xCD, 0xEF, 0xFD, 0x2A, 0x0E, 0xFF, 0x11, 0x28, 0x00, 0x19, 0x22, 0x0E, 0xFF,
			0x11, 0xD0, 0x02, 0xED, 0x52, 0x38, 0x0E, 0x11, 0x14, 0x00, 0xED, 0x52, 0x30, 0x07, 0x11, 0xDE,
			0x00, 0xED, 0x53, 0x0E, 0xFF, 0x2A, 0x0C, 0xFF, 0x11, 0x20, 0x00, 0x19, 0x22, 0x0C, 0xFF, 0x18,
			0xC0, 0xCD, 0x6D, 0xFE, 0x3E, 0x0D, 0x32, 0x18, 0xFF, 0x21, 0x00, 0x00, 0x22, 0x10, 0xFF, 0x3A,
			0x04, 0xFF, 0xC6, 0x40, 0x32, 0x23, 0xF8, 0x11, 0x14, 0xF8, 0x21, 0x25, 0x03, 0x01, 0x28, 0x00,
			0xCD, 0xEF, 0xFD, 0xDB, 0xE8, 0xE6, 0xE0, 0xF6, 0x14, 0xD3, 0xE8, 0xDB, 0xEA, 0xFE, 0xFF, 0x28,
			0x04, 0x06, 0x40, 0x18, 0x38, 0xDB, 0xE8, 0xE6, 0xE0, 0xF6, 0x15, 0xD3, 0xE8, 0xDB, 0xEA, 0xFE,
			0xFF, 0x28, 0x04, 0x06, 0x48, 0x18, 0x26, 0xDB, 0xE8, 0xE6, 0xE0, 0xF6, 0x16, 0xD3, 0xE8, 0xDB,
			0xEA, 0xFE, 0xFF, 0x28, 0x04, 0x06, 0x50, 0x18, 0x14, 0xDB, 0xE8, 0xE6, 0xE0, 0xF6, 0x17, 0xD3,
			0xE8, 0xDB, 0xEA, 0xFE, 0xFF, 0x28, 0x04, 0x06, 0x58, 0x18, 0x02, 0x18, 0xB6, 0xCB, 0x47, 0x20,
			0x02, 0x18, 0x2F, 0x04, 0xCB, 0x4F, 0x20, 0x02, 0x18, 0x28, 0x04, 0xCB, 0x57, 0x20, 0x02, 0x18,
			0x21, 0x04, 0xCB, 0x5F, 0x20, 0x02, 0x18, 0x1A, 0x04, 0xCB, 0x67, 0x20, 0x02, 0x18, 0x13, 0x04,
			0xCB, 0x6F, 0x20, 0x02, 0x18, 0x0C, 0x04, 0xCB, 0x77, 0x20, 0x02, 0x18, 0x05, 0x04, 0xCB, 0x7F,
			0x20, 0x81, 0x78, 0x32, 0x17, 0xFF, 0xFE, 0x40, 0xDA, 0x73, 0xF3, 0x47, 0x21, 0x04, 0xFF, 0x7E,
			0xC6, 0x40, 0xB8, 0xDA, 0x73, 0xF3, 0x3A, 0x17, 0xFF, 0xFE, 0x40, 0x20, 0x05, 0x3E, 0x2F, 0x32,
			0x17, 0xFF, 0x11, 0x17, 0xFF, 0x21, 0x3B, 0x03, 0x01, 0x01, 0x00, 0xCD, 0xEF, 0xFD, 0x3A, 0x17,
			0xFF, 0xFE, 0x2F, 0x20, 0x26, 0x11, 0x2E, 0xF8, 0x21, 0x48, 0x03, 0x01, 0x15, 0x00, 0xCD, 0xEF,
			0xFD, 0x21, 0x00, 0x00, 0x01, 0x00, 0x80, 0xDB, 0xF8, 0xAF, 0xD3, 0xF8, 0xD3, 0xF9, 0xDB, 0xF9,
			0x77, 0x23, 0x0B, 0x78, 0xB1, 0xC2, 0x3E, 0xF4, 0xC3, 0xC7, 0xFB, 0x21, 0x00, 0x00, 0x11, 0x20,
			0x00, 0x3A, 0x17, 0xFF, 0xD6, 0x41, 0x28, 0x04, 0x19, 0x3D, 0x20, 0xFC, 0x22, 0x19, 0xFF, 0x2A,
			0x19, 0xFF, 0x11, 0x02, 0x80, 0x19, 0xE5, 0xD1, 0x21, 0x55, 0x03, 0x01, 0x10, 0x00, 0xCD, 0xEF,
			0xFD, 0x11, 0x44, 0xF8, 0x21, 0x48, 0x03, 0x01, 0x0D, 0x00, 0xCD, 0xEF, 0xFD, 0xFD, 0x21, 0x20,
			0xFF, 0x21, 0x00, 0x80, 0xED, 0x5B, 0x19, 0xFF, 0x19, 0xE5, 0x11, 0x1E, 0x00, 0x19, 0x5E, 0x23,
			0x56, 0xED, 0x53, 0x12, 0xFF, 0xE1, 0xE5, 0x11, 0x13, 0x00, 0x19, 0x7E, 0x32, 0x1F, 0xFF, 0xE1,
			0xE5, 0x11, 0x14, 0x00, 0x19, 0x7E, 0xFD, 0x77, 0x02, 0x4F, 0x23, 0x7E, 0xFD, 0x77, 0x03, 0x47,
			0xE1, 0xE5, 0x11, 0x16, 0x00, 0x19, 0x5E, 0x23, 0x56, 0xD5, 0xDD, 0xE1, 0xE1, 0xE5, 0x11, 0x18,
			0x00, 0x19, 0x5E, 0x23, 0x56, 0xED, 0x53, 0xC5, 0xFB, 0xC5, 0xCD, 0xDD, 0xF5, 0x11, 0x75, 0xF8,
			0x21, 0x69, 0x03, 0x01, 0x0A, 0x00, 0xCD, 0xEF, 0xFD, 0xC1, 0x21, 0x00, 0x00, 0x22, 0x1D, 0xFF,
			0x21, 0xA0, 0xFB, 0xED, 0x42, 0xD2, 0x1C, 0xF5, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0x20, 0x03, 0xC3,
			0xBF, 0xF5, 0xC5, 0xD5, 0xE5, 0x2A, 0x12, 0xFF, 0x01, 0xE0, 0x00, 0x09, 0x22, 0x1B, 0xFF, 0xE5,
			0xFD, 0x6E, 0x02, 0xFD, 0x66, 0x03, 0x11, 0x00, 0xE0, 0xB7, 0xED, 0x52, 0x22, 0x1D, 0xFF, 0xE1,
			0xAF, 0xFD, 0x77, 0x02, 0x3E, 0xE0, 0xFD, 0x77, 0x03, 0xE1, 0xD1, 0xC1, 0xC3, 0xA0, 0xFB, 0x11,
			0x9B, 0xF7, 0x21, 0xC8, 0x00, 0x01, 0x28, 0x00, 0xCD, 0xEF, 0xFD, 0x11, 0xB6, 0xF7, 0x21, 0x90,
			0x01, 0x01, 0x28, 0x00, 0xCD, 0xEF, 0xFD, 0xCD, 0x17, 0xFC, 0xC3, 0x87, 0xFD, 0xCD, 0xB8, 0xFD,
			0x2A, 0x1D, 0xFF, 0x54, 0x5D, 0x2A, 0x1B, 0xFF, 0x3A, 0x14, 0xFF, 0x47, 0xC5, 0xD5, 0xE5, 0x3A,
			0x00, 0xFF, 0xFE, 0x32, 0x20, 0x26, 0x21, 0x00, 0x80, 0x11, 0x00, 0xD4, 0x01, 0x00, 0x04, 0xED,
			0xB0, 0x21, 0xAC, 0xF5, 0x11, 0xE8, 0xD3, 0x01, 0x13, 0x00, 0xED, 0xB0, 0x21, 0x8C, 0xF8, 0x11,
			0x00, 0x80, 0x01, 0x0F, 0x02, 0xED, 0xB0, 0xE1, 0xD1, 0xC1, 0x18, 0x29, 0x21, 0x00, 0x80, 0x11,
			0x00, 0x54, 0x01, 0x00, 0x04, 0xED, 0xB0, 0x21, 0xAC, 0xF5, 0x11, 0xE8, 0x53, 0x01, 0x13, 0x00,
			0xED, 0xB0, 0x21, 0x8C, 0xF8, 0x11, 0x00, 0x80, 0x01, 0x0F, 0x02, 0xED, 0xB0, 0x3E, 0xB7, 0x32,
			0x31, 0x80, 0xE1, 0xD1, 0xC1, 0x3A, 0x1F, 0xFF, 0x4F, 0xC3, 0x00, 0x80, 0x21, 0x00, 0xD4, 0x11,
			0x00, 0x80, 0x01, 0x00, 0x04, 0xED, 0xB0, 0xDB, 0xE2, 0xCB, 0xCF, 0xD3, 0xE2, 0x18, 0xFE, 0x11,
			0x52, 0xF8, 0x21, 0x70, 0x03, 0x01, 0x28, 0x00, 0xCD, 0xEF, 0xFD, 0xC3, 0x7B, 0xFD, 0xE5, 0xC5,
			0xE6, 0x0F, 0x06, 0x00, 0x4F, 0x21, 0x7C, 0xF8, 0x09, 0x7E, 0xC1, 0xE1, 0xC9, 0xE5, 0xD5, 0xC5,
			0xF5, 0x21, 0x76, 0xF8, 0x78, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB, 0x3F, 0xCD, 0xCE, 0xF5,
			0x77, 0x23, 0x78, 0xCD, 0xCE, 0xF5, 0x77, 0x23, 0x79, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB,
			0x3F, 0xCD, 0xCE, 0xF5, 0x77, 0x23, 0x79, 0xCD, 0xCE, 0xF5, 0x77, 0xF1, 0xC1, 0xD1, 0xE1, 0xC9,
			0xE5, 0x01, 0xE8, 0x03, 0x21, 0x00, 0xB0, 0x36, 0x20, 0x23, 0x0B, 0x78, 0xB1, 0x20, 0xF8, 0x2B,
			0x36, 0x0D, 0xE1, 0xE5, 0x11, 0x00, 0xB0, 0x19, 0xE5, 0xD1, 0xE1, 0x01, 0xE8, 0x03, 0xCD, 0xEF,
			0xFD, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0xC0, 0x01, 0xE8, 0x03, 0xED, 0x5B, 0x02, 0xFF, 0xDD, 0x21,
			0x00, 0x08, 0xDD, 0x19, 0xDD, 0x36, 0x00, 0x07, 0xDD, 0x23, 0x0B, 0x78, 0xB1, 0x20, 0xF5, 0xC9,
			0xE5, 0xFD, 0x21, 0x20, 0xFF, 0x32, 0x14, 0xFF, 0x3E, 0x00, 0xFD, 0x77, 0x02, 0x3E, 0x08, 0xFD,
			0x77, 0x03, 0x01, 0x10, 0x00, 0xED, 0x43, 0x12, 0xFF, 0xCD, 0xA3, 0xFC, 0xF5, 0xCD, 0x17, 0xFC,
			0xF1, 0xE1, 0xD8, 0x06, 0x40, 0xDD, 0xE5, 0xD1, 0x1A, 0x13, 0xFE, 0x01, 0x20, 0x09, 0xD5, 0xE5,
			0xCD, 0xBF, 0xF6, 0xE1, 0xD1, 0x38, 0x0D, 0xEB, 0xC5, 0x01, 0x1F, 0x00, 0x09, 0xC1, 0xEB, 0x05,
			0x20, 0xE6, 0x37, 0xC9, 0x01, 0x13, 0x00, 0xEB, 0x09, 0xEB, 0x1A, 0xFD, 0x77, 0x02, 0x13, 0x1A,
			0xFD, 0x77, 0x03, 0x13, 0x13, 0x13, 0x01, 0x06, 0x00, 0xEB, 0x09, 0xEB, 0x1A, 0x13, 0x4F, 0x1A,
			0x13, 0x47, 0xED, 0x43, 0x12, 0xFF, 0xCD, 0xA3, 0xFC, 0xF5, 0xCD, 0x17, 0xFC, 0xF1, 0xC9, 0x1A,
			0xBE, 0x20, 0x08, 0xFE, 0x0D, 0x13, 0x23, 0x20, 0xF6, 0x18, 0x02, 0xB7, 0xC9, 0x37, 0xC9, 0x49,
			0x50, 0x4C, 0x20, 0xBE, 0xDA, 0xB8, 0xC0, 0x2D, 0x20, 0x3C, 0x3C, 0x20, 0x4D, 0x5A, 0x2D, 0x38,
			0x30, 0x42, 0x20, 0xD3, 0x2D, 0xC4, 0xDE, 0x20, 0x3E, 0x3E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
			0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x49, 0x50, 0x4C, 0x20, 0xBE, 0xDA, 0xB8, 0xC0,
			0x2D, 0x20, 0x3C, 0x3C, 0x20, 0x4D, 0x5A, 0x2D, 0x32, 0x30, 0x30, 0x30, 0x2F, 0x32, 0x32, 0x30,
			0x30, 0x20, 0xD3, 0x2D, 0xC4, 0xDE, 0x20, 0x3E, 0x3E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
			0x0D, 0x49, 0x50, 0x4C, 0x20, 0xBE, 0xDA, 0xB8, 0xC0, 0x2D, 0x20, 0x3C, 0x3C, 0x20, 0x4D, 0x5A,
			0x2D, 0x32, 0x35, 0x30, 0x30, 0x20, 0xD3, 0x2D, 0xC4, 0xDE, 0x20, 0x3E, 0x3E, 0x20, 0x20, 0x20,
			0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x20, 0x20, 0x56, 0x65, 0x72, 0x30,
			0x2E, 0x39, 0x62, 0x4B, 0x61, 0x69, 0x20, 0x32, 0x30, 0x32, 0x32, 0x2E, 0x30, 0x34, 0x2E, 0x31,
			0x38, 0x20, 0x28, 0x63, 0x29, 0x20, 0x6B, 0x75, 0x72, 0x61, 0x6E, 0x2D, 0x6B, 0x75, 0x72, 0x61,
			0x6E, 0x0D, 0x4D, 0x5A, 0x2D, 0x32, 0x35, 0x30, 0x30, 0xD3, 0x2D, 0xC4, 0xDE, 0xC3, 0xDE, 0xC9,
			0x20, 0xC4, 0xDE, 0xB3, 0xBB, 0xB6, 0xB8, 0xC6, 0xDD, 0xCA, 0x20, 0xBC, 0xC3, 0xB2, 0xCF, 0xBE,
			0xDD, 0x20, 0x6D, 0x28, 0x2D, 0x20, 0x2D, 0x3B, 0x29, 0x6D, 0x0D, 0xB4, 0xD7, 0x2D, 0x20, 0x3A,
			0x20, 0xB7, 0xC4, 0xDE, 0xB3, 0xC3, 0xDE, 0xB7, 0xD9, 0xCC, 0xA7, 0xB2, 0xD9, 0xB6, 0xDE, 0x20,
			0xB1, 0xD8, 0xCF, 0xBE, 0xDD, 0x0D, 0x20, 0x20, 0x20, 0xC3, 0xDE, 0xA8, 0xBD, 0xB8, 0xA6, 0xBA,
			0xB3, 0xB6, 0xDD, 0xBC, 0xC3, 0x20, 0x49, 0x50, 0x4C, 0xD8, 0xBE, 0xAF, 0xC4, 0x20, 0xA6, 0x20,
			0xBC, 0xC3, 0xB8, 0xC0, 0xDE, 0xBB, 0xB2, 0x0D, 0x44, 0x49, 0x53, 0x4B, 0x20, 0xC0, 0xB2, 0xCC,
			0xDF, 0x20, 0x3A, 0x20, 0x32, 0x44, 0x44, 0x20, 0x44, 0x69, 0x73, 0x6B, 0x28, 0x38, 0x30, 0xBC,
			0xD8, 0xDD, 0xC0, 0xDE, 0x29, 0x0D, 0x44, 0x49, 0x53, 0x4B, 0x20, 0xC0, 0xB2, 0xCC, 0xDF, 0x20,
			0x3A, 0x20, 0x20, 0x32, 0x44, 0x20, 0x44, 0x69, 0x73, 0x6B, 0x28, 0x33, 0x35, 0xBC, 0xD8, 0xDD,
			0xC0, 0xDE, 0x29, 0x0D, 0xC4, 0xDE, 0xDA, 0xA6, 0xB7, 0xC4, 0xDE, 0xB3, 0xBC, 0xCF, 0xBD, 0xB6,
			0x5B, 0x41, 0x2D, 0x20, 0x2C, 0x2F, 0x5D, 0x20, 0x3D, 0x3D, 0x3E, 0x20, 0x20, 0x0D, 0x20, 0x20,
			0xD6, 0xD0, 0xBA, 0xDD, 0xC3, 0xDE, 0xB2, 0xCF, 0xBD, 0x20, 0x3A, 0x20, 0x4D, 0x5A, 0x2D, 0x31,
			0x52, 0x31, 0x32, 0x0D, 0x20, 0x20, 0xD6, 0xD0, 0xBA, 0xDD, 0xC3, 0xDE, 0xB2, 0xCF, 0xBD, 0x20,
			0x3A, 0x0D, 0xB4, 0xD7, 0x2D, 0x20, 0x3A, 0x20, 0x46, 0x42, 0x41, 0x30, 0x68, 0x42, 0x79, 0x74,
			0x65, 0x20, 0xA6, 0x20, 0xBA, 0xB4, 0xC3, 0xB2, 0xD9, 0xC9, 0xC3, 0xDE, 0x20, 0xD6, 0xD0, 0xBA,
			0xD2, 0xCF, 0xBE, 0xDD, 0x0D, 0x28, 0x6E, 0x6E, 0x6E, 0x6E, 0x29, 0x0D, 0x30, 0x31, 0x32, 0x33,
			0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x31, 0x00, 0x84, 0xDD,
			0x21, 0x00, 0xE0, 0xFD, 0x21, 0x07, 0x82, 0x78, 0x32, 0x04, 0x82, 0xFD, 0x73, 0x02, 0xFD, 0x72,
			0x03, 0x22, 0x02, 0x82, 0xC5, 0xCD, 0x0D, 0x81, 0xCD, 0x81, 0x80, 0xC1, 0x7A, 0xFE, 0x1F, 0x20,
			0x09, 0x7B, 0xFE, 0xFF, 0x20, 0x04, 0x79, 0x32, 0xFF, 0xFF, 0xDB, 0xE8, 0xCB, 0xF7, 0xCB, 0xFF,
			0xD3, 0xE8, 0xC3, 0xE8, 0xD3, 0x3A, 0x05, 0x82, 0x0F, 0xCD, 0x6B, 0x80, 0x3A, 0x04, 0x82, 0xF6,
			0x84, 0xD3, 0xDC, 0xAF, 0xCD, 0xF5, 0x81, 0x21, 0x00, 0x00, 0x2B, 0x7C, 0xB5, 0xCA, 0xDB, 0x81,
			0xDB, 0xD8, 0x2F, 0x07, 0x38, 0xF4, 0x3A, 0x04, 0x82, 0x4F, 0x21, 0x00, 0x82, 0x06, 0x00, 0x09,
			0xCB, 0x46, 0xC0, 0xCD, 0x9C, 0x80, 0xC9, 0x3E, 0x80, 0xD3, 0xDC, 0x06, 0x0A, 0x21, 0x19, 0x3C,
			0x2B, 0x7D, 0xB4, 0x20, 0xFB, 0x10, 0xF6, 0x3E, 0x01, 0x32, 0x05, 0x82, 0xC9, 0xCD, 0xEE, 0x81,
			0xAF, 0xD3, 0xDC, 0x32, 0x05, 0x82, 0xC9, 0x3E, 0x1B, 0x2F, 0xD3, 0xD8, 0xCD, 0xB4, 0x80, 0xCD,
			0xF5, 0x81, 0xDB, 0xD8, 0x2F, 0xE6, 0x99, 0xC9, 0xE5, 0x3E, 0x0B, 0x2F, 0xD3, 0xD8, 0xCD, 0xB4,
			0x80, 0xCD, 0xF5, 0x81, 0xDB, 0xD8, 0x2F, 0xE6, 0x85, 0xEE, 0x04, 0xE1, 0xC8, 0xC3, 0xDB, 0x81,
			0xD5, 0xE5, 0xCD, 0xE7, 0x81, 0x1E, 0x07, 0x21, 0x00, 0x00, 0x2B, 0x7C, 0xB5, 0x28, 0x09, 0xDB,
			0xD8, 0x2F, 0x0F, 0x38, 0xF5, 0xE1, 0xD1, 0xC9, 0x1D, 0x20, 0xEC, 0xC3, 0xDB, 0x81, 0x06, 0x00,
			0x11, 0x10, 0x00, 0x2A, 0x02, 0x82, 0xAF, 0xED, 0x52, 0x38, 0x03, 0x04, 0x18, 0xF9, 0x19, 0x60,
			0x2C, 0xFD, 0x74, 0x04, 0xFD, 0x75, 0x05, 0x3A, 0x04, 0x82, 0xFE, 0x04, 0x30, 0x18, 0xFD, 0x7E,
			0x04, 0xFE, 0xA0, 0x30, 0x11, 0xFD, 0x7E, 0x05, 0xB7, 0x28, 0x0B, 0xFE, 0x11, 0x30, 0x07, 0xFD,
			0x7E, 0x02, 0xFD, 0xB6, 0x03, 0xC0, 0xC3, 0xDB, 0x81, 0xF3, 0xCD, 0xD2, 0x80, 0x3E, 0x0A, 0x32,
			0x06, 0x82, 0xCD, 0x39, 0x80, 0xFD, 0x56, 0x03, 0xFD, 0x7E, 0x02, 0xB7, 0x28, 0x01, 0x14, 0xFD,
			0x7E, 0x05, 0xFD, 0x77, 0x01, 0xFD, 0x7E, 0x04, 0xFD, 0x77, 0x00, 0xDD, 0xE5, 0xE1, 0xCB, 0x3F,
			0x2F, 0xD3, 0xDB, 0x30, 0x04, 0x3E, 0x01, 0x18, 0x02, 0x3E, 0x00, 0x2F, 0xD3, 0xDD, 0xCD, 0x8B,
			0x80, 0x20, 0x6A, 0x0E, 0xDB, 0xFD, 0x7E, 0x00, 0xCB, 0x3F, 0x2F, 0xD3, 0xD9, 0xFD, 0x7E, 0x01,
			0x2F, 0xD3, 0xDA, 0xD9, 0x21, 0x8A, 0x81, 0xE5, 0xD9, 0x3E, 0x94, 0x2F, 0xD3, 0xD8, 0xCD, 0xC0,
			0x81, 0x06, 0x00, 0xDB, 0xD8, 0x0F, 0xD8, 0x0F, 0x38, 0xF9, 0xED, 0xA2, 0x20, 0xF5, 0xFD, 0x34,
			0x01, 0xFD, 0x7E, 0x01, 0xFE, 0x11, 0x28, 0x05, 0x15, 0x20, 0xE6, 0x18, 0x01, 0x15, 0x3E, 0xD8,
			0x2F, 0xD3, 0xD8, 0xCD, 0xB4, 0x80, 0xDB, 0xD8, 0x2F, 0xE6, 0xFF, 0x20, 0x20, 0xD9, 0xE1, 0xD9,
			0xFD, 0x7E, 0x01, 0xFE, 0x11, 0x20, 0x08, 0x3E, 0x01, 0xFD, 0x77, 0x01, 0xFD, 0x34, 0x00, 0x7A,
			0xB7, 0x20, 0x05, 0x3E, 0x80, 0xD3, 0xDC, 0xC9, 0xFD, 0x7E, 0x00, 0x18, 0x81, 0x3A, 0x06, 0x82,
			0x3D, 0x32, 0x06, 0x82, 0x28, 0x21, 0xCD, 0x9C, 0x80, 0xC3, 0x16, 0x81, 0xD5, 0xE5, 0xCD, 0xE7,
			0x81, 0x21, 0x00, 0x00, 0x2B, 0x7C, 0xB5, 0x28, 0x09, 0xDB, 0xD8, 0x2F, 0x0F, 0x30, 0xF5, 0xE1,
			0xD1, 0xC9, 0x1D, 0x20, 0xEC, 0x18, 0x00, 0xCD, 0x81, 0x80, 0x3E, 0xA5, 0xD3, 0xD9, 0xCD, 0xE7,
			0x81, 0x37, 0xC9, 0xD5, 0x11, 0x0D, 0x00, 0xC3, 0xF9, 0x81, 0xD5, 0x11, 0x82, 0x00, 0xC3, 0xF9,
			0x81, 0xD5, 0x11, 0x2C, 0x1A, 0x1B, 0x7B, 0xB2, 0x20, 0xFB, 0xD1, 0xC9, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0xA3, 0xFC, 0xCD, 0x17, 0xFC, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0x20, 0x05, 0xAF, 0xD3, 0xB4,
			0xD3, 0xB5, 0x2A, 0x1D, 0xFF, 0x7C, 0xB5, 0xCA, 0xBD, 0xFB, 0xC3, 0x3D, 0xF5, 0x2A, 0xC5, 0xFB,
			0x7C, 0xB5, 0x28, 0x03, 0xC3, 0x00, 0x00, 0xDB, 0xE2, 0xCB, 0xCF, 0xD3, 0xE2, 0x18, 0xFE, 0x3A,
			0x15, 0xFF, 0x0F, 0xCD, 0x01, 0xFC, 0x3A, 0x14, 0xFF, 0xF6, 0x84, 0xD3, 0xDC, 0xAF, 0xCD, 0xA6,
			0xFD, 0x21, 0x00, 0x00, 0x2B, 0x7C, 0xB5, 0xCA, 0x71, 0xFD, 0xDB, 0xD8, 0x2F, 0x07, 0x38, 0xF4,
			0x3A, 0x14, 0xFF, 0x4F, 0x21, 0x10, 0xFF, 0x06, 0x00, 0x09, 0xCB, 0x46, 0xC0, 0xCD, 0x32, 0xFC,
			0xC9, 0x3E, 0x80, 0xD3, 0xDC, 0x06, 0x0A, 0x21, 0x19, 0x3C, 0x2B, 0x7D, 0xB4, 0x20, 0xFB, 0x10,
			0xF6, 0x3E, 0x01, 0x32, 0x15, 0xFF, 0xC9, 0xCD, 0x9F, 0xFD, 0xAF, 0xD3, 0xDC, 0x32, 0x15, 0xFF,
			0xC9, 0x3E, 0x1B, 0x2F, 0xD3, 0xD8, 0xCD, 0x4A, 0xFC, 0xCD, 0xA6, 0xFD, 0xDB, 0xD8, 0x2F, 0xE6,
			0x99, 0xC9, 0xE5, 0x3E, 0x0B, 0x2F, 0xD3, 0xD8, 0xCD, 0x4A, 0xFC, 0xCD, 0xA6, 0xFD, 0xDB, 0xD8,
			0x2F, 0xE6, 0x85, 0xEE, 0x04, 0xE1, 0xC8, 0xC3, 0x71, 0xFD, 0xD5, 0xE5, 0xCD, 0x98, 0xFD, 0x1E,
			0x07, 0x21, 0x00, 0x00, 0x2B, 0x7C, 0xB5, 0x28, 0x09, 0xDB, 0xD8, 0x2F, 0x0F, 0x38, 0xF5, 0xE1,
			0xD1, 0xC9, 0x1D, 0x20, 0xEC, 0xC3, 0x71, 0xFD, 0x06, 0x00, 0x11, 0x10, 0x00, 0x2A, 0x12, 0xFF,
			0xAF, 0xED, 0x52, 0x38, 0x03, 0x04, 0x18, 0xF9, 0x19, 0x60, 0x2C, 0xFD, 0x74, 0x04, 0xFD, 0x75,
			0x05, 0x3A, 0x14, 0xFF, 0xFE, 0x04, 0x30, 0x18, 0xFD, 0x7E, 0x04, 0xFE, 0xA0, 0x30, 0x11, 0xFD,
			0x7E, 0x05, 0xB7, 0x28, 0x0B, 0xFE, 0x11, 0x30, 0x07, 0xFD, 0x7E, 0x02, 0xFD, 0xB6, 0x03, 0xC0,
			0xC3, 0x71, 0xFD, 0xF3, 0xCD, 0x68, 0xFC, 0x3E, 0x0A, 0x32, 0x16, 0xFF, 0xCD, 0xCF, 0xFB, 0xFD,
			0x56, 0x03, 0xFD, 0x7E, 0x02, 0xB7, 0x28, 0x01, 0x14, 0xFD, 0x7E, 0x05, 0xFD, 0x77, 0x01, 0xFD,
			0x7E, 0x04, 0xFD, 0x77, 0x00, 0xDD, 0xE5, 0xE1, 0xCB, 0x3F, 0x2F, 0xD3, 0xDB, 0x30, 0x04, 0x3E,
			0x01, 0x18, 0x02, 0x3E, 0x00, 0x2F, 0xD3, 0xDD, 0xCD, 0x21, 0xFC, 0x20, 0x6A, 0x0E, 0xDB, 0xFD,
			0x7E, 0x00, 0xCB, 0x3F, 0x2F, 0xD3, 0xD9, 0xFD, 0x7E, 0x01, 0x2F, 0xD3, 0xDA, 0xD9, 0x21, 0x20,
			0xFD, 0xE5, 0xD9, 0x3E, 0x94, 0x2F, 0xD3, 0xD8, 0xCD, 0x56, 0xFD, 0x06, 0x00, 0xDB, 0xD8, 0x0F,
			0xD8, 0x0F, 0x38, 0xF9, 0xED, 0xA2, 0x20, 0xF5, 0xFD, 0x34, 0x01, 0xFD, 0x7E, 0x01, 0xFE, 0x11,
			0x28, 0x05, 0x15, 0x20, 0xE6, 0x18, 0x01, 0x15, 0x3E, 0xD8, 0x2F, 0xD3, 0xD8, 0xCD, 0x4A, 0xFC,
			0xDB, 0xD8, 0x2F, 0xE6, 0xFF, 0x20, 0x20, 0xD9, 0xE1, 0xD9, 0xFD, 0x7E, 0x01, 0xFE, 0x11, 0x20,
			0x08, 0x3E, 0x01, 0xFD, 0x77, 0x01, 0xFD, 0x34, 0x00, 0x7A, 0xB7, 0x20, 0x05, 0x3E, 0x80, 0xD3,
			0xDC, 0xC9, 0xFD, 0x7E, 0x00, 0x18, 0x81, 0x3A, 0x16, 0xFF, 0x3D, 0x32, 0x16, 0xFF, 0x28, 0x21,
			0xCD, 0x32, 0xFC, 0xC3, 0xAC, 0xFC, 0xD5, 0xE5, 0xCD, 0x98, 0xFD, 0x21, 0x00, 0x00, 0x2B, 0x7C,
			0xB5, 0x28, 0x09, 0xDB, 0xD8, 0x2F, 0x0F, 0x30, 0xF5, 0xE1, 0xD1, 0xC9, 0x1D, 0x20, 0xEC, 0x18,
			0x00, 0xCD, 0x17, 0xFC, 0x3E, 0xA5, 0xD3, 0xD9, 0xCD, 0x98, 0xFD, 0x11, 0x98, 0xFE, 0x21, 0x98,
			0x03, 0x01, 0x50, 0x00, 0xCD, 0xEF, 0xFD, 0xCD, 0x6D, 0xFE, 0xCD, 0xA6, 0xFD, 0xCD, 0x6D, 0xFE,
			0xCD, 0xA6, 0xFD, 0xCD, 0x6D, 0xFE, 0x18, 0xFE, 0xD5, 0x11, 0x0D, 0x00, 0xC3, 0xAA, 0xFD, 0xD5,
			0x11, 0x82, 0x00, 0xC3, 0xAA, 0xFD, 0xD5, 0x11, 0x2C, 0x1A, 0x1B, 0x7B, 0xB2, 0x20, 0xFB, 0xD1,
			0xC9, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0x28, 0x09, 0xDB, 0xE8, 0xCB, 0xF7, 0xCB, 0xFF, 0xD3, 0xE8,
			0xC9, 0x3E, 0x06, 0xD3, 0xB4, 0x3E, 0x38, 0xD3, 0xB5, 0x3A, 0x01, 0xFF, 0xFE, 0x48, 0xC8, 0x3E,
			0x02, 0x32, 0x5D, 0xFE, 0xC9, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0xCA, 0xE6, 0xFD, 0xDB, 0xE8, 0xCB,
			0xB7, 0xCB, 0xBF, 0xD3, 0xE8, 0xC9, 0x3E, 0x06, 0xD3, 0xB4, 0x3E, 0x0F, 0xD3, 0xB5, 0xC9, 0xE5,
			0xD5, 0xC5, 0xF5, 0xDD, 0xE5, 0xFD, 0xE5, 0xCD, 0xB1, 0xFD, 0xCD, 0x09, 0xFE, 0xCD, 0xD5, 0xFD,
			0xFD, 0xE1, 0xDD, 0xE1, 0xF1, 0xC1, 0xD1, 0xE1, 0xC9, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0x28, 0x1D,
			0xC5, 0xED, 0x4B, 0x02, 0xFF, 0x09, 0xE5, 0xDD, 0xE1, 0xD5, 0xE1, 0xC1, 0x7E, 0xFE, 0x0D, 0xC8,
			0xDD, 0x77, 0x00, 0x23, 0xDD, 0x23, 0x0B, 0x78, 0xB1, 0xC2, 0x1C, 0xFE, 0xC9, 0xC5, 0xD5, 0xED,
			0x4B, 0x02, 0xFF, 0x09, 0xE5, 0xDD, 0xE1, 0xDD, 0xE5, 0xFD, 0xE1, 0x01, 0x00, 0x10, 0xFD, 0x09,
			0xE1, 0xC1, 0x7E, 0xFE, 0x0D, 0xC8, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB, 0x3F, 0xCB, 0x3F,
			0xCB, 0x3F, 0xF6, 0x8C, 0xFD, 0x77, 0x00, 0x7E, 0xCB, 0x27, 0xCB, 0x27, 0xF6, 0x00, 0xDD, 0x77,
			0x00, 0x23, 0xFD, 0x23, 0xDD, 0x23, 0x0B, 0x78, 0xB1, 0xC2, 0x42, 0xFE, 0xC9, 0xC5, 0x01, 0x32,
			0x00, 0x3E, 0x05, 0xD3, 0xE3, 0xCD, 0x86, 0xFE, 0x3E, 0x04, 0xD3, 0xE3, 0xCD, 0x86, 0xFE, 0x0B,
			0x78, 0xB1, 0x20, 0xED, 0xC1, 0xC9, 0xD5, 0x11, 0x64, 0x00, 0x3A, 0x00, 0xFF, 0xFE, 0x35, 0xC2,
			0xAA, 0xFD, 0x11, 0x82, 0x00, 0xC3, 0xAA, 0xFD, 0xDB, 0x2D, 0xC4, 0xDE, 0xB4, 0xD7, 0x2D, 0xB6,
			0xDE, 0xCA, 0xAF, 0xBE, 0xB2, 0xBC, 0xCF, 0xBC, 0xC0, 0x20, 0x49, 0x50, 0x4C, 0xD8, 0xBE, 0xAF,
			0xC4, 0xBC, 0xC3, 0xB8, 0xC0, 0xDE, 0xBB, 0xB2, 0x20, 0x6D, 0x28, 0x20, 0x20, 0x20, 0x29, 0x6D,
			0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
			0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
			0x20, 0x20, 0x20, 0x5F, 0x20, 0x5F, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};
		buffer.resize(sizeof(iplSelectorImage));
		memcpy_s(&buffer[0], buffer.size(), iplSelectorImage, sizeof(iplSelectorImage));
	}
	WriteSector(buffer, 0, static_cast<int>(buffer.size()) / 256);
}

//============================================================================
//  ディレクトリ位置を設定する
//----------------------------------------------------------------------------
// In  : ディレクトリのあるセクタ番号 (-1=ルートディレクトリ)
// Out : なし
//============================================================================
void MzDisk::SetDirSector( int sector )
{
	if( -1 == sector )
	{
		this->dirSector = 0x10;
	}
	else
	{
		this->dirSector = sector;
	}
	ReadDirectory();
}

//============================================================================
//  ディレクトリ位置を取得する
//----------------------------------------------------------------------------
// In  : なし
// Out : ディレクトリのあるセクタ番号
//============================================================================
int MzDisk::GetDirSector( void )
{
	return this->dirSector;
}

int MzDisk::GetDirCount(void)
{
	return static_cast<int>(this->directory.size());
}

//============================================================================
//  ディレクトリ情報を取得する
//----------------------------------------------------------------------------
// In  : ディレクトリ番号 (0〜63);
// Out : なし
//============================================================================
void MzDisk::GetDir(void* dirData, int dirindex)
{
	memcpy(dirData, &this->directory[dirindex], sizeof(DIRECTORY));
}

//============================================================================
//  ディレクトリ情報を書き込む
//----------------------------------------------------------------------------
// In  : ディレクトリ番号 (0〜63);
// Out : なし
//============================================================================
void MzDisk::SetDir(void* dirData, int dirindex)
{
	memcpy(&this->directory[dirindex], dirData, sizeof(DIRECTORY));
	// 管理情報をD88イメージに書き込み
	FlushWrite();
}

//============================================================================
//  ディレクトリを表示する (ルートのみ)
//----------------------------------------------------------------------------
// In  : なし
// Out : なし
//============================================================================
#if false
void MzDisk::DisplayDir(void)
{
	char fileName[ 18 ];
	int mode;
	struct {
		unsigned char mode;
		char modeStr[ 6 ];
	} ModeTbl[] = {
		0x01, "OBJ  ",
		0x02, "BTX  ",
		0x03, "BSD  ",
		0x04, "BRD  ",
		0x05, "RB   ",
		0x07, "LIB  ",
		0x0A, "SYS  ",
		0x0B, "GR   ",
		0x0F, "DIR  ",
		0x80, "NSWAP",
		0x81, "SWAP "
	};
	// インデックス
	printf("Mode  Filename             Size Load  Run  Sec\n");
	printf("+---+ +-----------------+ +---+ +--+ +--+ +--+\n");
	// ファイル情報表示
	for(int i = 0; i < 64; ++ i)
	{
		if(this->directory[i].mode != 0)
		{
			mode = -1;
			for(int j = 0; j < 10; ++ j)
			{
				if(this->directory[i].mode == ModeTbl[j].mode)
				{
					mode = j;
					break;
				}
			}
			if((mode >= 0) && (mode < 9))
			{
				// モード
				printf("%02d %5s ", i, ModeTbl[mode].modeStr);
				// ファイルネーム
				memset(&fileName, 0, 18);
				memcpy(&fileName, this->directory[i].filename, 17);
				for(int j = 0; j < 17; ++ j)
				{
					if(fileName[j] == 0x0D)
					{
						fileName[j] = 0;
					}
				}
				printf("\"%s\" ", fileName);
				for(int j = 0; j < (17 - (int)strlen(fileName)); ++ j)
				{
					printf(" ");
				}
				// ファイルサイズ
				printf("%5d ", this->directory[i].size);
				// ロードアドレス
				printf("%04X ", this->directory[i].loadAdr);
				// 実行アドレス
				printf("%04X ", this->directory[i].runAdr);
				// 格納セクタ
				printf("%04X\n", this->directory[i].startSector);
			}
		}
	}
}
#endif

//============================================================================
//  パス名から拡張子を取得する
//----------------------------------------------------------------------------
// In  : path = ファイル
//     : extfilename = 拡張子格納領域
// Out : なし
//============================================================================
void MzDisk::GetExtFilename(std::string path, std::string& extfilename)
{
	size_t loop = 4;
	size_t extpos;
	extfilename.resize(4, 0);
	size_t length = path.size();
	if(length > 2)
	{
		if(loop > length)
		{
			loop = length;
		}
		extpos = -1;
		for(size_t i = 0; i < loop; ++ i) 
		{
			if(path[length - i - 1] == '.')
			{
				extpos = length - i - 1 + 1;
				break;
			}
		}
		if(extpos != -1)
		{
			for(size_t i = 0; i < 3; ++ i)
			{
				if(path[extpos] == '\0')
				{
					break;
				}
				extfilename[i] = path[extpos];
				extpos++;
			}
		}
	}
}

//============================================================================
//	パス名から拡張子を削除する
//----------------------------------------------------------------------------
// In  : path = パス名
// Out : なし
//============================================================================
void MzDisk::DeleteFileExtname(std::string path)
{
	size_t loop = 4;
	size_t length = path.size();
	if(length > 2)
	{
		if(loop > length)
		{
			loop = length;
		}
		for(size_t i = 0; i < loop; ++ i)
		{
			if(path[length - i - 1] == '.')
			{
				path[length - i - 1] = '\0';
				break;
			}
		}
	}
}

void MzDisk::WriteUseSize(void)
{
	int size = 0;
	int end = this->bitmap[4] + this->bitmap[5] * 256;
	for(int i = 48; i < end; ++ i)
	{
		unsigned char bit = (this->bitmap[i / 8] >> (i % 8)) & 1;
		if(bit == 1)
		{
			++ size;
		}
	}
	size += this->bitmap[1];
	this->bitmap[2] = size % 256;
	this->bitmap[3] = size / 256;
}

// ビットマップ、ディレクトリをD88に書き込む
void MzDisk::FlushWrite(void)
{
	std::vector<unsigned char> writeBuffer;
	// ビットマップ書き込み
	std::copy(this->bitmap.begin(), this->bitmap.end(), std::back_inserter(writeBuffer));
	WriteSector(writeBuffer, 15, 1);
	// ディレクトリ書き込み
	WriteDirectory();
}

int MzDisk::GetUseBlockSize(void)
{
	if(this->image.IsValid() == false)
	{
		return 0;
	}
	return this->bitmap[2] + this->bitmap[3] * 256;
}

int MzDisk::GetAllBlockSize(void)
{
	if(this->image.IsValid() == false)
	{
		return 0;
	}
	return this->bitmap[4] + this->bitmap[5] * 256;
}

int MzDisk::GetClusterSize(void)
{
	if(this->image.IsValid() == false)
	{
		return 0;
	}
	return this->clusterSize;
}

// D88イメージからディレクトリデータをthis->directryに読み込む
void MzDisk::ReadDirectory(void)
{
	if(this->image.IsValid() == false)
	{
		return;
	}
	this->directory.clear();
	std::vector<unsigned char> buffer;
	ReadSector(buffer, this->dirSector, 8);
	size_t directoryCount = this->sectorSize * 8 / 32;
	for(size_t i = 0; i < directoryCount; ++ i)
	{
		DIRECTORY* directory = reinterpret_cast<DIRECTORY*>(&buffer[i * 32]);
		this->directory.push_back(*directory);
	}
}

// ディレクトリデータをthis->directryからD88イメージに書き込む
void MzDisk::WriteDirectory(void)
{
	std::vector<unsigned char> writeBuffer;
	writeBuffer.clear();
	unsigned char* copyBuffer = reinterpret_cast<unsigned char*>(&this->directory[0]);
	std::copy(copyBuffer, copyBuffer + static_cast<size_t>(this->sectorSize) * 8, std::back_inserter(writeBuffer));
	WriteSector(writeBuffer, this->dirSector, 8);
}

void MzDisk::ReadSector(std::vector<unsigned char>& buffer, int sector, int numOfSector)
{
	for(int i = 0; i < numOfSector; ++ i)
	{
		int readSector = sector + i;
		int track = readSector / 16;
		int c = track / 2;
		int h = 1 - (track % 2);
		int r = readSector % 16 + 1;
		D88Image::SectorInfo sectorInfo;
		std::vector<unsigned char> readBuffer;
		this->image.ReadSector(sectorInfo, readBuffer, c, h, r);
		ReverseBuffer(readBuffer);
		std::copy(readBuffer.begin(), readBuffer.end(), std::back_inserter(buffer));
	}
}

void MzDisk::WriteSector(std::vector<unsigned char>& buffer, int sector, int numOfSector)
{
	for(int i = 0; i < numOfSector; ++ i)
	{
		int writeSector = sector + i;
		int track = writeSector / 16;
		int c = track / 2;
		int h = 1 - (track % 2);
		int r = writeSector % 16 + 1;
		D88Image::SectorInfo sectorInfo;
		this->image.GetSectorInfo(sectorInfo, c, h, r);
		std::vector<unsigned char> writeBuffer;
		std::copy(&buffer[static_cast<size_t>(this->sectorSize) * i], &buffer[static_cast<size_t>(this->sectorSize) * i] + this->sectorSize, std::back_inserter(writeBuffer));
		ReverseBuffer(writeBuffer);
		this->image.WriteSector(sectorInfo, writeBuffer, c, h, r);
	}
}
